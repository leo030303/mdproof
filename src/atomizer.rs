use cmark::TagEnd;

use crate::cmark::{Event as ParseEvent, Parser, Tag};
use crate::style::{Class, Style};
use crate::util::{slice_cow_from_idx, slice_cow_till_idx};
use std::borrow::Cow;

pub struct Atomizer<'src> {
    state: AtomizerState<'src>,
    parser: Parser<'src>,
    current_style: Style,
    is_code: bool,
    is_alt_text: bool,
}

#[derive(Debug)]
enum AtomizerState<'src> {
    /// The atomizer is splitting text apart
    Splitting(Cow<'src, str>),
    /// The atomizer is matching events generated by the markdown parser
    Parsing,
}

#[derive(Debug)]
pub enum Event<'src> {
    Atom(Atom<'src>),
    Break(Break),
    StartBlock(BlockTag),
    EndBlock(BlockTag),
}

#[derive(Debug)]
pub enum Atom<'src> {
    Text { text: Cow<'src, str>, style: Style },
    Image { uri: Cow<'src, str> },
}

#[derive(Debug)]
pub enum Break {
    Word,
    Line,
    Paragraph,
    HorizontalRule,
    Page,
}

#[derive(Debug)]
pub enum BlockTag {
    BlockQuote,
    CodeBlock,
    List(Option<usize>),
    ListItem,
}

impl<'src> Iterator for Atomizer<'src> {
    type Item = Event<'src>;

    fn next(&mut self) -> Option<Self::Item> {
        loop {
            let state = ::std::mem::replace(&mut self.state, AtomizerState::Parsing);
            let (next_event, next_state) = match state {
                AtomizerState::Parsing => match self.parser.next() {
                    Some(parser_event) => self.parse_event(parser_event),
                    None => break,
                },
                AtomizerState::Splitting(text) => self.split_text(text),
            };
            self.state = next_state;
            if next_event.is_some() {
                return next_event;
            }
        }
        None
    }
}

impl<'src> Atomizer<'src> {
    pub fn new(parser: Parser<'src>) -> Self {
        Atomizer {
            state: AtomizerState::Parsing,
            parser,
            current_style: Style::default(),
            is_code: false,
            is_alt_text: false,
        }
    }

    fn split_text(&mut self, text: Cow<'src, str>) -> (Option<Event<'src>>, AtomizerState<'src>) {
        if text.len() == 0 || self.is_alt_text {
            return (None, AtomizerState::Parsing);
        }
        match text.chars().next().expect("string len must be > 0") {
            ' ' => {
                if self.is_code {
                    return (
                        Some(Event::Atom(Atom::Text {
                            text: " ".into(),
                            style: self.current_style.clone(),
                        })),
                        AtomizerState::Splitting(slice_cow_from_idx(&text, 1)),
                    );
                } else {
                    return (
                        Some(Event::Break(Break::Word)),
                        AtomizerState::Splitting(slice_cow_from_idx(&text, 1)),
                    );
                }
            }
            '\n' => {
                return (
                    Some(Event::Break(Break::Line)),
                    AtomizerState::Splitting(slice_cow_from_idx(&text, 1)),
                )
            }
            _ => {}
        }
        if text
            .chars()
            .next()
            .map(|c| c.is_whitespace())
            .unwrap_or(false)
        {
            return (None, AtomizerState::Splitting(slice_cow_from_idx(&text, 1)));
        }
        let style = self.current_style.clone();
        for (idx, c) in text.char_indices() {
            let end = match c {
                ' ' | '\n' => Some(idx),
                _ => None,
            };
            if let Some(idx) = end {
                let remainder = slice_cow_from_idx(&text, idx);
                let text = slice_cow_till_idx(&text, idx);
                return (
                    Some(Event::Atom(Atom::Text { text, style })),
                    AtomizerState::Splitting(remainder),
                );
            }
        }
        (
            Some(Event::Atom(Atom::Text { text, style })),
            AtomizerState::Parsing,
        )
    }

    fn parse_event(
        &mut self,
        event: ParseEvent<'src>,
    ) -> (Option<Event<'src>>, AtomizerState<'src>) {
        match event {
            ParseEvent::Start(Tag::Strong) => self.current_style.insert(Class::Strong),
            ParseEvent::End(TagEnd::Strong) => self.current_style.remove(&Class::Strong),
            ParseEvent::Start(Tag::Emphasis) => self.current_style.insert(Class::Emphasis),
            ParseEvent::End(TagEnd::Emphasis) => self.current_style.remove(&Class::Emphasis),
            ParseEvent::Start(Tag::CodeBlock(_)) => self.current_style.insert(Class::Code),
            ParseEvent::End(TagEnd::CodeBlock) => self.current_style.remove(&Class::Code),

            ParseEvent::Rule => {
                return (
                    Some(Event::Break(Break::HorizontalRule)),
                    AtomizerState::Parsing,
                )
            }

            ParseEvent::Start(Tag::Heading {
                level: size,
                id: _id,
                classes: _classes,
                attrs: _attrs,
            }) => self.current_style.insert(Class::Heading(size as u8)),
            ParseEvent::End(TagEnd::Heading(size)) => {
                self.current_style.remove(&Class::Heading(size as u8));
                return (Some(Event::Break(Break::Paragraph)), AtomizerState::Parsing);
            }

            ParseEvent::Start(Tag::List(first_number)) => {
                return (
                    Some(Event::StartBlock(BlockTag::List(
                        first_number.map(|value| value as usize),
                    ))),
                    AtomizerState::Parsing,
                )
            }
            ParseEvent::End(TagEnd::List(is_ordered)) => {
                if is_ordered {
                    return (
                        Some(Event::EndBlock(BlockTag::List(Some(1)))),
                        AtomizerState::Parsing,
                    );
                } else {
                    return (
                        Some(Event::EndBlock(BlockTag::List(None))),
                        AtomizerState::Parsing,
                    );
                }
            }

            ParseEvent::Start(Tag::Item) => {
                return (
                    Some(Event::StartBlock(BlockTag::ListItem)),
                    AtomizerState::Parsing,
                )
            }
            ParseEvent::End(TagEnd::Item) => {
                return (
                    Some(Event::EndBlock(BlockTag::ListItem)),
                    AtomizerState::Parsing,
                )
            }

            ParseEvent::Start(Tag::BlockQuote(_)) => {
                return (
                    Some(Event::StartBlock(BlockTag::BlockQuote)),
                    AtomizerState::Parsing,
                )
            }
            ParseEvent::End(TagEnd::BlockQuote(_)) => {
                return (
                    Some(Event::EndBlock(BlockTag::BlockQuote)),
                    AtomizerState::Parsing,
                )
            }

            ParseEvent::Text(text) => return (None, AtomizerState::Splitting(text.into())),

            ParseEvent::Html(html) => {
                use quick_xml::{events::Event as XMLEvent, Reader};
                let mut reader = Reader::from_str(&html);
                let reader_config = reader.config_mut();
                reader_config.trim_text(true);

                loop {
                    match reader.read_event() {
                        Ok(XMLEvent::Start(ref e)) => {
                            for attr in e.html_attributes() {
                                let attr = match attr {
                                    Ok(a) => a,
                                    Err(_) => continue,
                                };
                                if attr.key == quick_xml::name::QName(b"style")
                                    && &attr.value[..] == b"page-break-after:always;"
                                {
                                    return (
                                        Some(Event::Break(Break::Page)),
                                        AtomizerState::Parsing,
                                    );
                                }
                            }
                        }

                        Ok(XMLEvent::Eof) => break,
                        _ => {}
                    }
                }
            }

            ParseEvent::Start(Tag::Image {
                link_type: _link_type,
                dest_url,
                title: _title,
                id: _id,
            }) => {
                self.is_alt_text = true;
                return (
                    Some(Event::Atom(Atom::Image {
                        uri: dest_url.into(),
                    })),
                    AtomizerState::Parsing,
                );
            }
            ParseEvent::End(TagEnd::Image) => {
                self.is_alt_text = false;
            }

            ParseEvent::Start(Tag::CodeBlock(_src_type)) => {
                self.is_code = true;
                self.current_style.insert(Class::Code);
                self.current_style.insert(Class::Code);
                return (
                    Some(Event::StartBlock(BlockTag::CodeBlock)),
                    AtomizerState::Parsing,
                );
            }
            ParseEvent::End(TagEnd::CodeBlock) => {
                self.is_code = false;
                self.current_style.remove(&Class::Code);
                return (
                    Some(Event::EndBlock(BlockTag::CodeBlock)),
                    AtomizerState::Parsing,
                );
            }

            ParseEvent::Start(Tag::Paragraph) => {}
            ParseEvent::End(TagEnd::Paragraph) => {
                return (Some(Event::Break(Break::Paragraph)), AtomizerState::Parsing)
            }

            ParseEvent::SoftBreak => {
                return (Some(Event::Break(Break::Word)), AtomizerState::Parsing)
            }
            ParseEvent::HardBreak => {
                return (Some(Event::Break(Break::Line)), AtomizerState::Parsing)
            }

            _ => {}
        };
        (None, AtomizerState::Parsing)
    }
}
